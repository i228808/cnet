//
// Generated file, do not edit! Created by opp_msgtool 6.1 from src/CNETPacket.msg.
//

#ifndef __CNETFINAL_CNETPACKET_M_H
#define __CNETFINAL_CNETPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0601
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace cnetfinal {

class CNETPacket;

}  // namespace cnetfinal


namespace cnetfinal {

/**
 * Class generated from <tt>src/CNETPacket.msg:8</tt> by opp_msgtool.
 * <pre>
 * // Basic packet structure for CNETFINAL simulations
 * // We'll use string for IPs for simplicity with current FirewallRule, 
 * // but a dedicated IPAddress class would be better for IPUtils.
 * packet CNETPacket
 * {
 *     string sourceIP;
 *     string destinationIP;
 *     int sourcePort = -1;       // -1 if not applicable
 *     int destinationPort = -1;  // -1 if not applicable
 *     string protocol;         // e.g., "TCP", "UDP", "ICMP", "DHCP_DISCOVER", "DNS_QUERY"
 *     // Potentially add a payload field if needed, e.g., string payloadData;
 * }
 * 
 * // Specific message types for services, can extend CNETPacket or be separate
 * // For now, we can use the protocol field in CNETPacket to distinguish.
 * 
 * // Example for DHCP (can be refined later)
 * // packet DHCPDiscover extends CNETPacket {
 * //    protocol = "DHCP_DISCOVER";
 * //    // DHCP specific fields like MAC address, transaction ID etc.
 * // }
 * 
 * // packet DHCPOffer extends CNETPacket {
 * //    protocol = "DHCP_OFFER";
 * //    // Offered IP, lease time, server IP etc.
 * // }
 * </pre>
 */
class CNETPacket : public ::omnetpp::cPacket
{
  protected:
    ::omnetpp::opp_string sourceIP;
    ::omnetpp::opp_string destinationIP;
    int sourcePort = -1;
    int destinationPort = -1;
    ::omnetpp::opp_string protocol;

  private:
    void copy(const CNETPacket& other);

  protected:
    bool operator==(const CNETPacket&) = delete;

  public:
    CNETPacket(const char *name=nullptr, short kind=0);
    CNETPacket(const CNETPacket& other);
    virtual ~CNETPacket();
    CNETPacket& operator=(const CNETPacket& other);
    virtual CNETPacket *dup() const override {return new CNETPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const char * getSourceIP() const;
    virtual void setSourceIP(const char * sourceIP);

    virtual const char * getDestinationIP() const;
    virtual void setDestinationIP(const char * destinationIP);

    virtual int getSourcePort() const;
    virtual void setSourcePort(int sourcePort);

    virtual int getDestinationPort() const;
    virtual void setDestinationPort(int destinationPort);

    virtual const char * getProtocol() const;
    virtual void setProtocol(const char * protocol);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CNETPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CNETPacket& obj) {obj.parsimUnpack(b);}


}  // namespace cnetfinal


namespace omnetpp {

template<> inline cnetfinal::CNETPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<cnetfinal::CNETPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __CNETFINAL_CNETPACKET_M_H

